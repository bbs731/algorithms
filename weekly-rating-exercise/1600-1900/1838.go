package _600_1900

import "sort"

/*

元素的 频数 是该元素在一个数组中出现的次数。

给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。

执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。



示例 1：

输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
示例 2：

输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
示例 3：

输入：nums = [3,9,6], k = 2
输出：1


提示：

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= 10^5

 */
func maxFrequency(nums []int, k int) int {
	n := len(nums)
	ans := 0
	sort.Ints(nums)

	psum := make([]int, n+1)
	for i := 0; i < n; i++ {
		psum[i+1] = psum[i] + nums[i]
	}

	// 难度 1876 的题， 其实很简单， 但是把我的胆，都吓破了，你找菠萝的心理素质差多了！
	// 差分然后求前缀和，不就是 nums 自己吗？ 所以这里不需要差分， 好好想想，如何计算 sum

	// 想到了用二分， 晃动窗口，应该也是可以的。

	for i := 0; i < n; i++ { // 枚举端点
		// 用二分查找来，找到满足 sum <=k 的右端点。
		left, right := i, n-1

		for left <= right {
			mid := (left + right) / 2
			total := nums[mid]*(mid-i) - (psum[mid] - psum[i]) // 这里想错了！
			if total <= k { // 根据，题目的要求， 二分的条件判断是变化的，每个题目都不一样，不能死记硬背 < 还是 <= 要根据题目的需求考。 考虑循环不变量，然后最后决定用 left, 还是 right 作为结果。
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
		ans = max(ans, right-i+1) // 考虑一下循环不变量。为啥这里用的 right 不是 left
	}

	return ans
}
